# 1장: 시작하기 전에

- 2014년에 깃허브에 오픈 소스로 처음 발표되었고, 이후에는 계속 성장해서 주요 클라우드 서비스는 모두 매니지드 쿠버네티스 환경을 서비스 한다. 데이터 센서에도, 노트북에서도 실행할 수 있고 실행 되는 서비스는 모두 같은 쿠버네티스 이다.
- 쿠버네티스의 인기가 높은 이유는 독립적 + 표준적 지위를 점하고 있기 때문
  - 쿠버네티스를 통해 어디서는 배포가 가능하도록 하여줌
  - 클라우드 환경, 데이터센터 등을 오가며 코드를 수정하지 않아서 서비스를 이전 할 수 있음
    → 이를 통해 환경을 옮기더라도 기존 생산성을 유지할 수 있음.
- 쿠버네티스 자체가 어렵기 때문에 생각보다 만드는 과정이 그렇게 녹록치 않음.
  - 간단한 어플이여도 여러 개의 컴포넌트로 구성해야 됨 → 때로는 수백 줄에 따르는 낯선 포맷의 스크립트로 작성해줘야 함
  - 기존에 인프라스트럭처에서 다루는 로드밸런싱 + 네트워크 + 스토리지 + 컴퓨팅을 애플리케이션 설정의 영역으로 데려옴.

## 1.1 쿠버네티스 이해하기

- 쿠버네티스는 컨데이터를 실행하는 플랫폼
  - 컨테이너화된 애플리케이션의 시작
  - 롤링 업데이트
  - 서비스 수준 유지
  - 수요에 따른 스케일링
  - 보안 접근
  → 위와 같은 기능들을 제공하여 줌
- 핵심 개념
  - 애플리케이션 정의에 사용되는 API
  - 애플리케이션이 실제로 동작하는 클러스터(Cluster)
    → 도커와 같은 컨테이너 런타임이 동작하는 여러 대의 서버가 모여 쿠버네티스 같은 논리적 단위를 구성한 것을 의미함.
    ![스크린샷 2023-09-21 오후 2.38.20.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0483f3fb-e84e-43e6-b3c7-d93e74749b98/e55296b1-164c-44fd-b278-a472123fb55d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.38.20.png)
  - 클러스터 관리자는 노드(일종의 서버)를 관리함
    - 클러스터의 처리 용량을 확장하기 위해 노드를 추가, 노드를 서비스에서 제외가능
    - 클러스터 내 노드를 차례로 업데이트 하는 롤링 업데이트 적용 가능
    - Azure의 쿠버네티스 서비스나 AWS의 Elastic Kubernetes 서비스를 통해서 이런 기능을 편리하게 사용 가능
- 쿠버네티스 클러스터의 목적 → 애플리케이션을 실행하는 것
  - YAML 파일에 애플리케이션을 기술하고 이 파일을 쿠버네티스 API에 전달하면 쿠버네티스가 해당 파일의 구성을 이해하고 클러스터의 현재 상태와 비교하게 됨.
  - 파일에 기술된 바람직한 상태와 차이가 있다면 컨테이너를 추가 혹은 제거하게 된다.
    ![스크린샷 2023-09-21 오후 2.44.22.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0483f3fb-e84e-43e6-b3c7-d93e74749b98/9b4e3ab8-6905-4cf7-a406-398bb8f33292/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.44.22.png)
  - 컨테이너는 고가용성을 위해서 여러 노드로 흩어져 있고 쿠버네티스가 관리하는 가상 네트워크로 서로 통신을 할 수 있다.
  - 위의 이미지 수준에서는 각각의 노드를 신경 쓸 필요가 없다는 점
  - 애플리케이션 구성을 파일에 기술만 하면 쿠버네티스가 실행해주고 관리해줌
    - 어떤 노드가 고장을 일으키더라도 해당 노드에서 실행되던 컨테이너는 다른 노드에서 실행된 컨테이너로 대체 되어짐
    - 특정 컨테이너 이상 시에 쿠버네티스가 해당 컨테리너를 재시작 시켜줌.
    - 애플리케이션의 컴포넌트 중 하나의 부하가 높아지면, 추가로 컨테이너를 실행
    ⇒ 도커 이미지 + 쿠버네티스 YAML 파일만 있으면 모든 쿠버네티스 클러스터에서 동일하게 동작하는 **자가 복수형 애플리케이션**을 만들 수 있다!!
- 쿠버네티스는 분산 데이터 베이스가 들어 있고, 이를 관리한다.
  → 이 점 덕분에 쿠버네티스가 완전한 애플리케이션 플랫폼이 될 수 있음.
  - 분산데이터 내에 있는 것
    - 애플리케이션 구성 정보
    - API 키
    - 데이터베이스 접속 패스워드
  - 쿠버네티스는 이들 정보를 자연스럽게 컨테이너에 전달하여 준다.
- 쿠버네티스의 추가 기능
  ![스크린샷 2023-09-21 오후 2.58.01.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0483f3fb-e84e-43e6-b3c7-d93e74749b98/26f10d31-eb06-4108-87c2-59626978fd5d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.58.01.png)
  - 클러스터에 정확한 설정이 들어 있다면 어떤 환경이라도 동일한 컨테이너 이미지 사용 가능
  - 쿠버네티스는 스토리지도 제공
    - 이를 이용, 컨테이너 외부에 데이터 저장 가능 + 유상태 애플리케이션(?) 이라도 고가용성을 확보 가능
  - 클러스터로 들어오는 트래픽 관리
  - 각 요청을 해당하는 컨테이너로 전달하는 기능도 있음.
- 컨테이너에서 동작하는 애플리케이션은 다양함.
  - 클라우드에 적합한 MSA 아키텍처 애플리케이션을 여러 컨테이너에 실행 가능
  - 모놀리식 아키텍처로 설계된 레거시 애플리케이션을 단일 컨테이너로도 실행가능
  → 어떤 애플리케이션이든 그 구성을 동일한 API를 사용하는 YAML 파일로 기술하면 모두를 하나의 클러스터에서 실행할 수 있다!
  **⇒ 쿠버네티스의 가장 큰 장점 → 모든 애플리케이션을 어떠한 종류든 같은 방식으로 기술하고 배포하고 관리할 수 있다는 것!**
- 위에서 나온 개념들의 정확한 이름ㄴ
  - YAML 파일 → 애플리케이션을 기술해둔 문서 → **애플리케이션 매니페스트**
    - 파일 내용이 애플리케이션을 구성하는 모든 컴포넌트의 목록을 다루기 대문에 이름이 이렇다.
  - 리소스 → 쿠버네티스에서 애플리케이션을 구성하는 컴포넌트

## 1.2 이 책의 대상 독자

## 1.3 실습 환경 만들기

- 쿠버네티스 클러스터는 수백 대 이상의 노드로 구성된다.
- 쿠버네티스 자체의 구성요소는 리눅스 컨테이너 형태이기 대문에 쿠버네티스 자체를 윈도우에서 실행해줄 수는 없다. → 가상 머신을 사용하여야 되는데 도커 데스크톱을 사용하면 이런 가상 머신까지 알아서 해결 해준다.
